# Chapter6 HTTP의 기본

# 01 HTTP의 중요성

- RFC 2616에서 규정된 프로토콜, 버전 1.1
- 실제 HTML, XML같은 하이퍼텍스트뿐만 아니라 이미지, 음성, 동영상, JavaScript 프로그램, PDF와 각종 오피스 문서 파일 등 컴퓨터에서 다룰 수 있는 데이터라면 무엇이든 전송할 수 있습니다.
- REST의 중요한 특징인 Uniform 인터페이스, 스테이트리스트 서버, 캐시 등을 구현하고 있는 Web의 기반이 되는 프로토콜입니다.

# 02 TCP/IP란 무엇일까

- HTTP는 TCP/IP를 기반으로 하고 있습니다.
- TCP (Transmission Control Protocol)
- IP (Internet Protocol)
- 계층형 프로토콜 : 각 계층별로 추상화하여 구현

![Chapter6%20HTTP%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20fb79205cc5e646b7b8c7c919e565f9e1/Untitled.png](Chapter6%20HTTP%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20fb79205cc5e646b7b8c7c919e565f9e1/Untitled.png)

- **네트워크 인터페이스 계층**

    물리적인 케이블이나 네트워크 어댑터에 해당하는 부분

    **이더넷** : [https://ko.wikipedia.org/wiki/이더넷](https://ko.wikipedia.org/wiki/%EC%9D%B4%EB%8D%94%EB%84%B7)

- **인터넷 계층**

    역할 : 네트워크에서 데이터를 실제로 주고받는 것

    **IP**가 여기에 해당하며, IP에서는 데이터의 기본적인 통신단위를 **패킷Packet**이라고 부르고, 지정한 IP 어드레스와 패킷 단위로 데이터를 주고받으면서 통신합니다.

    [https://ko.wikipedia.org/wiki/네트워크_패킷](https://ko.wikipedia.org/wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%ED%8C%A8%ED%82%B7)

- **트랜스포트 계층 (전송)**

    역할 : 데이터의 무결성을 보증하는 것

    **TCP**가 여기에 해당하며, 목적지의 상대에 대해서 커넥션을 연결, 사용한 데이터의 누락을 체크하고 데이터의 도달을 보증합니다.

    TCP로 접속된 커넥션에서 전송하는 데이터가 어느 애플리케이션으로 전달될지 결정하는 것이 포트번호입니다. 1~65535까지 사용하며, 서버에서 자주 사용하는 번호에는 디폴트 번호가 할당되어 있습니다. HTTP의 경우 80번 포트를 사용

- **애플리케이션 계층 (응용)**

    구체적인 인터넷 애플리케이션, 가령 메일, **DNS**, 그리고 HTTP를 실현하는 계층입니다.

    TCP로 프로그램을 만들 때는 **소켓(socket)**이라고 불리는 라이브러리를 사용하는 것이 일반적입니다.

    소켓은 네트워크에서의 데이터 교환을 추상화한 API로 접속, 송신, 수신, 절단 등의 기본적인 기능을 갖추고 있습니다. HTTP 서버와 브라우저는 소켓을 이용하여 구현합니다.

    [https://ko.wikipedia.org/wiki/네트워크_소켓](https://ko.wikipedia.org/wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%EC%86%8C%EC%BC%93)

    [https://ko.wikipedia.org/wiki/도메인_네임_시스템](https://ko.wikipedia.org/wiki/%EB%8F%84%EB%A9%94%EC%9D%B8_%EB%84%A4%EC%9E%84_%EC%8B%9C%EC%8A%A4%ED%85%9C)

# 03 HTTP의 버전

- 1.1 버전 이전

    HTTP 0.9 - HTTP의 탄생 : 버너스-리 1990년 웹 발명 시 사용했던 프로토콜

    HTTP 1.0 - HTTP 최초의 표준화, 헤더의 도입, GET 이외의 메서드 추가 등 HTTP 1.1로 이어지는 기본적인 요소들이 도입

- **HTTP 1.1. - HTTP의 완성**

    채널 전송, Accept 헤더에 의한 **콘텐트 네고시에시션**, 복잡한 캐시 컨트롤, 지속적 연결 등의 기능 추가

    [https://developer.mozilla.org/ko/docs/Web/HTTP/Content_negotiation](https://developer.mozilla.org/ko/docs/Web/HTTP/Content_negotiation)

- 그 후의 HTTP

    논의, 버전 업 등 → X, 최종적으로 HTTP 자체의 가치를 REST 아키텍처 스타일에서 찾아낸 결과, HTTP 1.1을 효과적으로 활용하자는 것이 현대적인 개발 스타일이 되었습니다.

# 04 클라이언트와 서버

- HTTP의 구체적인 구조
- 웹은 아키텍처 스타일로 클라이언트/서버를 채용하고 있음 (클라이언트 Request ↔ 서버 Response)

# 05 요청과 응답

- 요청/응답형 프로토콜 Request-Response Style
- HTTP가 동기형 프로토콜 Synchronous 이기에 서버에서의 처리에 시간이 오래 걸리더라도 요청을 보낸 클라이언트는 응답이 돌아올 때까지 대기합니다.

### 클라이언트에서 일어나는 일들

- 요청을 송신하고 응답받을 때 다음의 일들을 수행
1. 요청 메시지 구축
2. 요청 메시지 송신
3. (응답이 돌아올 때까지 대기)
4. 응답 메시지 수신
5. 응답 메시지 해석
6. 클라이언트의 목적을 달성하기 위해 필요한 처리

### 서버에서 일어나는 일들

- 클라이언트로부터 요청을 받은 서버는 다음의 일들을 수행
1. (요청을 대기)
2. 요청 메시지 수신
3. 요청 메시지 해석
4. 적절한 애플리케이션 프로그램으로 처리를 위임
5. 애플리케이션 프로그램으로부터 결과를 취득
6. 응답 메시지 구축
7. 응답 메시지 송신

# 06 HTTP 메시지

요청 메시지와 응답 메시지를 합해서 HTTP 메시지라고 부릅니다.

### 요청 메시지

GET /test HTTP/1.1
Host: example.com

**요청 라인 Request-Line** : 요청 메시지의 첫 번째 라인, 메서드(GET), 요청 URI(/test), 프로토콜 버전(HTTP/1.1)으로 구성됩니다.

**헤더 :** 요청메시지의 둘째 줄 부터는 ****헤더가 이어집니다**.** 메시지의 메타 데이터(데이터를 기술하는 데이터), 하나의 메시지는 복수의 헤더를 가질 수 있습니다. 각 헤더는 '이름:값'의 구성을 하고 있습니다.

**바디** : 예시에는 X, 바디에는 그 메시지를 나타내는 본질적인 정보가 들어갑니다. 예를 들어 리소스를 새로 작성하거나 갱신할 때에는 요청의 바디부분에 리소스의 표현자체가 들어갑니다.

### 응답 메시지

HTTP/1.1 200 OK
Content-Type: application/xhtml+xml: charset=utf-8

<html xmlns="http://www.w3.org/1999/xhtml">
....
</html>

**스테이터스 라인** : 응답 메시지의 첫째 줄은 스테이터스 라인이라고 한다. 프로토콜 버전(HTTP/1.1), 스테이서스 코드(200), 텍스트 구문(OK)으로 구성

**헤더** : 응답 메시지의 둘째 줄부터는 요청메시지와 마찬가지로 헤더. Content-Type 헤더에서 HTML의 MIME(Multipurpose Internet Mail Extension) 미디어 타입(application.xhtml+xml)과 그 문자 인코딩 방식(utf-8)을 지정하고 있습니다.

**바디** : 헤더와 바디는 빈 줄(해더 맨 마지막 줄 끝에 연속하는 CRLF)로 구분 됩니다. 이 예에서는 바디에 HTML이 포함되어 있습니다.

### HTTP 메시지의 구성요소

![Chapter6%20HTTP%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20fb79205cc5e646b7b8c7c919e565f9e1/Untitled%201.png](Chapter6%20HTTP%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20fb79205cc5e646b7b8c7c919e565f9e1/Untitled%201.png)

# 07 HTTP의 스테이트리스성

- HTTP는 스테이트리스(Stateless)한 프로토콜로 설계되어 있습니다.
- 스테이트리스란? '서버가 클라이언트의 애플리케이션 상태를 보존하지 않는다'는 제약
- 애플리케이션 상태란? ex) 햄버거 가게의 예(스테이트풀한 대화 vs 스테이트리스한 대화)

    → 간결 vs 장황, 주문 기억 vs 모든 주문 반복

### 애플리케이션 상태 = 세션 상태(Session State)

- 세션 : 시스템에 로그인하고부터 로그아웃할 때까지 일련의 조작을 모은 것
- FTP : 대표적인 스테이트풀한 프로토콜, 애플리케이션 상태를 서버가 관리, 상대 경로 지정 가능

### 스테이트풀의 결점

- 클라이언트 수가 증가함에 따라 상태를 기억하는 것이 어려워짐 → 규모 확장이 어렵다

![Chapter6%20HTTP%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20fb79205cc5e646b7b8c7c919e565f9e1/Untitled%202.png](Chapter6%20HTTP%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20fb79205cc5e646b7b8c7c919e565f9e1/Untitled%202.png)

### 스테이트리스의 이점

- 자기 기술적 메시지(Self Descriptive Message)
- 클라이언트가 자신의 애플리케이션 상태를 기억하고 모든 요청을 자기 기술적 메시지로 송신
- 서버 시스템이 단순해짐, 오는 요청을 처리하는데 집중 가능, 규모 확장이 쉽다

![Chapter6%20HTTP%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20fb79205cc5e646b7b8c7c919e565f9e1/Untitled%203.png](Chapter6%20HTTP%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20fb79205cc5e646b7b8c7c919e565f9e1/Untitled%203.png)

### 스테이트리스의 결점

- **퍼포먼스의 저하** : 매번 필요한 정보를 모두 송신 → 송신할 데이터 양이 많아진다. 인증 등 서버에 부하가 걸리는 처리를 반복한다.
- **통신 에러에 대한 대처** : 이미 처리된 상태인지 모르기 때문에 중복으로 처리할 수 있다.

# 08 심플한 프로토콜의 강점

- HTTP의 가장 큰 특징은 심플함!
- 심플 → 다양한 디바이스에 구현 가능