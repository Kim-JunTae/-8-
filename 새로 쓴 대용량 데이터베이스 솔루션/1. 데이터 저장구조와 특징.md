# 데이터 저장구조와 특징

- 정리하려다 중지

    # 1.1 테이블과 인덱스의 분리형

    - 인덱스 : 데이터를 저장하는 테이블과 특정한 데이터를 찾기 위한 경로로 사용

    관계형 데이터베이스 이전에서는 대부분 키(Key)와 데이터가 매우 밀접한 관련이 있었다.
    키를 찾는 것이 곧 데이터를 찾는 것이 되었다.

    테이블과 인덱스가 별도로 분리되어 있는 구조는 관계형 데이터베이스의 가장 일반적인 데이터 저장형식이다.

    ## 1.1.1. 분리형 테이블의 구조

    - 테이블 스페이스 : 논리적인 저장공간, 물리적인 데이터파일로 구성
    - 세그먼트(Segment) : 테이블스페이스를 용도별로 나눌수 있습니다, 데이터 오브젝트가 들어올 수 있다.
    - ROWID : 오브젝트번호+데이터파일번호+블록번호+슬롯번호 로 구성되어 인덱스에 존재. 블록 내에서 로우의 위치가 이동하더라도 rowid는 변하지 않는다.
    - 파티션(Partition) : 파티션이 발생한 테이블이나 인덱스는 각각의 파티션이 단위 오브젝트가 된다.
    - 작은 조각(Fragmentation)
    - 응축(Condensing) 작업
    - 로우의 이주(Migration)
    - 체인(Chain)

    ## 1.1.2. 클러스터링 팩터(clustering factor)

    분리형 테이블 구조가 가지는 최대의 특징은 바로 데이터의 값에 전혀 무관하게 '임의의 위치'에 저장된다는 것, 우리가 원하는 값을 찾으려면 필연적으로 여러 곳을 찾아보아야 한다는 것을 의미

    ### 클러스터링 팩터

    인덱스의 컬럼값으로 정렬되어 이는 인덱스 로우의 순서와 테이블에 저장되어 있는 데이터 로우의 위치가 얼마나 비슷한 순서로 저장되어 있느냐의 정도를 나타낸 것

    클러스터링 팩터가 좋은 인덱스로 액세스를 하면 많은 로우를 액세스 하더라도 보다 적은 블록을 액세스하게 되어 효율적일 수 있다.

    ## 1.1.3. 분리형 테이블의 액세스 영향요소

    분리형 테이블이 가지는 구조적인 특징들은 필연적으로 액세스 효율에 커다란 영향을 미치게 된다.

    ### 1.1.3.1. 넓은 범위의 액세스 처리에 대한 대처방안

    이 형태는 데이터가 들어오는 대로 아무곳에나 저장되는 형태이기 때문에 특정한 조건의 데이터를 액세스하고자 할 때는 아무래도 그만큼의 대가를 지불해야하는 것은 당연한다.

    - 소형 테이블
    - 중형 테이블
    - 대형 테이블

    ### 1.1.3.2. 클러스터링 팩터 향상 전략

    저장되어 있는 데이터의 응집도를 높여주는 방법, 주기적으로 테이블을 재생성시켜주는 방법 사용

    자주 범위처리하는 컬럼들로 정렬하여 저장

    테이블 재생성 시 주의할 점, 테이블에 데이터를 저장할 때 관련된 인덱스를 모두 제거하거나 비활성 시키는 것이 좋다. 인덱스를 생성한 채로 대량의 데이터를 저장하면 테이블의 저장 속도가 크게 저하될 뿐만 아니라 인덱스에 많은 분할이 발생하여 인덱스 저장 밀도가 매우 나빠진다.

    # 1.2 인덱스 일체형 테이블(Index-Organized Table)

    일반적으로 사용하는 B-Tree 인덱스는 '인덱스 컬럼 + ROWID'로 구성되어 있다.

    ## 1.2.1. 분리형과 일체형의 비교

    [제목 없음](https://www.notion.so/5dd479d620e24e979f6657ecf36963df)

    ![%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%203c9e8c58d4154414a51fa625716597ef/Untitled.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%203c9e8c58d4154414a51fa625716597ef/Untitled.png)

    ## 1.2.2. 일체형 테이블의 구조 및 특징

    모두 가지고 있기 떄문에 인덱스를 찾고 ROWID를 가지고 테이블의 데이터를 엑세스 할 필요가 없다.

    장점

    단점

    ## 1.2.3. 논리적 ROWID와 물리적 주소(Physical Guess)

    일체형 테이블은 인덱스의 분할에 따라 rowid가 변할 수 있으므로 어떤 키값이 동일한 노드에 지속적으로 저장될 수 없다.

    ## 1.2.4. 오버플로우 영역(Overflow Area)

    ## 1.2.5. 일체형 테이블의 생성

    ---

    # 1.3 클러스터링 테이블

    ## 1.3.1. 클러스터링 테이블의 개념

    ## 1.3.2. 단일테이블 클러스터링

    ## 1.3.3. 다중테이블 클러스터링

    ## 1.3.4. 클러스터링 테이블의 비용

    ### 1.3.4.1. 입력(INSERT) 시의 부하

    ### 1.3.4.2. 수정(UPDATE) 시의 부하

    ### 1.3.4.3. 삭제(DELETE) 시의 부하

    ## 1.3.5 해쉬(Hash) 클러스터링

    ### 1.3.5.1. 해쉬 클러스터의 특징

    ### 1.3.5.2. 해쉬 클러스터의 활용 범위

    ### 1.3.5.3. 해쉬 클러스터의 정의

    ### 1.3.5.4. 단일테이블 해쉬 클러스터(Single-table hash cluster)

# 용어

- 인덱스(index)

    ### 테이블에 대한 동작의 속도를 높여주는 자료 구조

    테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성 가능하며, 고속의 검색 동작뿐만 아니라 레코드의 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공한다.

    - **인덱스를 사용하는 이유**
        - WHERE 구문과 일치하는 열을 빨리 찾기 위해서
        - 열을 고려 대상에서 빨리 없애버리기 위해서
        - JOIN을 실행할 때 다른 테이블에서 열을 추출하기 위해서
        - 특정하게 인덱스된 컬럼을 위한 MIN() 또는 MAX() 값을 찾기 위해서
        - 사용할 수 있는 키의 최 좌측 접두사(leftmost prefix)를 가지고 정렬 및 그룹화를 하기 위해서
        - 데이터 열을 참조하지 않는 상태로 값을 추출하기 위해서 쿼리를 최적화 하는 경우에
    - **인덱스를 사용해야 하는 경우**
        - 데이터 양이 많고 검색이 변경보다 번번한 경우
        - 인덱스를 걸고자 하는 필드의 값이 다양한 값을 가지는 경우

    ### 인덱스의 사용

    - 기존의 테이블에 인덱스 추가하기

    ```java
    ALTER TABLE 테이블명 ADD INDEX(필드명(크기));
    mysql> ALTER TABLE temp ADD INDEX(keyword(20));
    ```

    - 테이블 생성시 인덱스 추가하기

    ```java
    CREATE TABLE 테이블 명(필드명 데이터타입(데이터크기), INDEX(필드명(크기))
    ENGINE MyISAM;

    mysql> CREATE TABLE test (
    			keyword varhar(20),
    			INDEX(keyword(20)))
    			ENGINE MyISAM;
    ```

    - 출처

        [https://itrainbowm.tistory.com/20](https://itrainbowm.tistory.com/20)

- 실행계획(Execution Plan)

    ### SQL에서 요구한 사항을 처리하기 위한 절차와 방법을 의미

    옵티마이저는 다양한 처리 방법들 중에서 가장 효율적인 방법을 찾아준다.
    (최적의 실행계획을 생성)

    - **실행계획의 구성요소**
        - **조인 순서(JOIN Order)**

            수행할 때 참조하는 테이블의 순서

            FROM A INNER JOIN B : A→B

        - **조인 기법(JOIN Method)**

            두 개의 테이블을 조인할 때 사용할 수 있는 방법

            NL Join, Hash Join, Sort Merge Join 등이 존재

        - **엑세스 기법(Access Method)**

            하나의 테이블을 엑세스할 때 사용할 수 있는 방법

            - 인덱스 스캔 (Index Scan)
            - 전체 테이블 스캔 (Full Table Scan)
        - **최적화 정보(Optimization Information)**

            옵티마이저가 실행계획의 각 단계마다 예상되는 비용 사항을 표시한 것

            최적화 정보에는 Cost, Card, Bytes가 존재

            - Cost : 상대적인 비용 정보
            - Card : Cardinality의 약자, 주어진 조건을 만족한 결과 집합 혹은 조인 조건을 만족한 결과 집합의 건수를 의미
            - Bytes는 결과 집합이 차지하는 메모리 양을 바이트로 표시한 것
        - **연산(Operation)**

            여러 가지 조작을 통해서 원하는 결과를 얻어내는 일련의 작업

            연산에는 조인 기법, 엑세스 기법, 필터, 정렬, 집계, 뷰 등 다양한 종류가 존재

        - 출처

            [https://blog.cornsworld.co.kr/82](https://blog.cornsworld.co.kr/82)

- 옵티마이저(Optimizer)

    ### SQL을 가장 빠르고 효율적으로 수행할 최적(최저비용)의 처리경로를 생성해 주는 DBMS 내부의 핵심엔진

    - 출처
        - [https://velog.io/@yewon-july/Optimizer](https://velog.io/@yewon-july/Optimizer)
        - [https://cornswrold.tistory.com/81](https://cornswrold.tistory.com/81)
- 테이블스페이스(Tablespace)

    ### 데이터베이스 오브젝트 내 실제 데이터를 저장하는 공간

    물리적인 부분이며, 세그먼트로 관리되는 모든 DBMS에 대해 저장소(세그먼트)를 할당한다.

    ![%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%203c9e8c58d4154414a51fa625716597ef/Untitled%201.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%203c9e8c58d4154414a51fa625716597ef/Untitled%201.png)

    ![%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%203c9e8c58d4154414a51fa625716597ef/Untitled%202.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%203c9e8c58d4154414a51fa625716597ef/Untitled%202.png)

    - 세그먼트 Segment

        하나의 테이블스페이스 내부에 저장된 각 데이터베이스 오브젝트

    - 익스텐트

        하나의 세그먼트에 할당된 공간

    - 출처

        [https://itragdoll.tistory.com/67](https://itragdoll.tistory.com/67)[https://jhkang-tech.tistory.com/221](https://jhkang-tech.tistory.com/221)

- 클러스터링 팩터(Clustering Factor)

    ### 인덱스의 컬럼값으로 정렬되어 있는 인덱스 로우의 순서와 
    테이블에 저장되어 있는 데이터 로우의 위치가 
    얼마나 비슷한 순서로 저장되어 있는냐에 대한 정도

- 인덱스 일체형 테이블(Index-Organized Table)

    ### 인덱스와 다른 일반 컬럼들이 모두 같은 위치에 저장되는 형태

- 클러스터링 테이블
    - 클러스터 : 테이블이나 인덱스처럼 저장공간을 가지고 있는 하나의 오브젝트, 테이블의 상위 개념 (클러스터 > 테이블 > 인덱스)
    - 비유

        어떤 지역(Tablespace)에 공장(Table)이 들어옴. 
        각자 자기가 확보한 임의의 위치(Segment)에 공장을 세움. 
        이들 간에는 서로 제품(Row)을 원재료서 주고 받아야 하므로 
        이를 위해 도로(Relationship)가 복잡하게 연결되어 있다.
        특정한 물건이 일련의 가공(Process)을 거쳐
        완제품(Application)이 되려면 다양한 공장을 복잡하게 거쳐야만 한다.

        만약 멀리 떨어져있는 공장(Table) 간 
        매우 빈번하게 재료가 공급(Join)되어야 한다면 
        운송단가(Clustering Factor)가 높아서 많은 비용(Cost, Resource)이 소요되고 
        생산성(Performance)은 급격하게 저하됨
        이런 경우에 두 공장을 인접한 곳에 배치(같은 클러스터 내에 생성)하여
        콘베이어 벨트(Cluster Key)를 설치한다면
        엄청난 연결(Join) 효율을 얻을 수 있을 것이다.
        이러한 목적으로 테이블을 클러스터링하는 방법을 
        **'다중 테이블 클러스터링(Multi-table clustering)'**이라고 한다. 

        어떤 단위 창고(Table)에 
        수많은 부품(Row)들이 무질서하게 보관(분리형 테이블 구조)되어 있고
        이를 찾아(Access)내기 위해 각 부품들의 위치를 알 수 있는 목록(Index)이 있다고 하자. 소량의 부품을 찾는 것은 큰 부담 X, 대량의 부품을 일시에 찾는다면 많은 부담 발생

        이러한 문제를 해결하기 위해 창고 내부를 섹터(Sector, Cluster)로 나누고
        각 섹터에는 동일한 유형의 부품(동일한 Cluster Key를 갖는 Row)을 보관
        이렇게 보관하면 이를 찾기 위한 목록(Cluster Index)도 각 부품마다 가질 필요없이 섹터별로만 있어도 충분하다. 이러한 방식은 대량의 동일한 부품을 찾을 때는 한 번만 목록을 참조하여 해당 섹터를 찾으면(Cluster Scan) 쉽게 대량의 부품을 매우 싼 단가로 찾을 수 있다.
        이처럼 대량의 범위를 효율적으로 엑세스하기 위해 클러스터링을 하는 방법을 **'단일 테이블 클러스터링(Single Table Clustering)'**이라고 한다.

    ### 단일테이블 클러스터링

    지정된 클러스터에 하나의 테이블만 생성시키는 것

    같은 클러스터 컬럼값을 가진 로우는 같은 장소에 저장되므로 넓은 범위의 데이터를 동시에 엑세스하고자 할 때 주로 활용된다.

    ![%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%203c9e8c58d4154414a51fa625716597ef/Untitled%203.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%203c9e8c58d4154414a51fa625716597ef/Untitled%203.png)

    ### 다중테이블 클러스터링

    단위 클러스터에 두 개 이상의 테이블을 함께 저장하는 것

    같은 클러스터키 컬럼값을 가진 각 테이블의 로우는 정해진 장소에 같이 저장되므로 테이블을 조인하는 속도를 향상시키고자 할 때 주로 활용

    ![%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%203c9e8c58d4154414a51fa625716597ef/Untitled%204.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%203c9e8c58d4154414a51fa625716597ef/Untitled%204.png)

explain : 어떤 인덱스

### 진우의 추가 강의

- BTREE 와 이진트리(Binary Tree)

    트리 자료구조의 일종, 이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조

    내부 노드의 자식 노드의 수가 미리 정해진 범위 내에서 변경가능하다는 것

    ![%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%203c9e8c58d4154414a51fa625716597ef/Untitled%205.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%203c9e8c58d4154414a51fa625716597ef/Untitled%205.png)

    - [https://helloinyong.tistory.com/296](https://helloinyong.tistory.com/296)
- primary index(clustering index), secondary index
    - primary index

    - secondary index
- LOB

    구조화되지 않은 대형 데이터를 저장하는데 사용한다.

    - 출처

    [https://stepping.tistory.com/30](https://stepping.tistory.com/30)

- 분산 sql

    여러 데이터 원본의 데이터를 엑세스하는 것